---
layout: page
type: article
---

{%- include snippets/assign.html
  target = site.data.variables.default.page.sharing
  source0=layout.sharing source1=page.sharing -%}
{%- assign _sharing = __return -%}

<div class="layout--article">
  {%- include article/top/custom.html -%}

  <div class="article__content" itemprop="articleBody">
    {{ content }}

    {%- if page.filter == "project" -%}
      <!-- 1) Checkbox filters -->
      <div class="subjects">
        {%- assign nav_group = site.data.navigation["projects"] -%}

        <div class="search search--bright">
          <div class="main">
            <div class="search-bar">
              <div class="search-box js-search-box not-empty">
                <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
                <input type="text" class="">
                <div class="search-box__icon-clear js-icon-clear">
                  <a><i class="fas fa-times"></i></a>
                </div>
              </div>
            </div>
            <div class="search-result js-search-result"></div>
          </div>
        </div>

        <!-- Platform -->
        <div class="filter">
          <strong>Platform:</strong>
          {%- assign platforms = "" | split: "" -%}
          {%- for grp in nav_group -%}
            {%- for item in grp.children -%}
              {%- for p in item.platform -%}
                {%- unless platforms contains p -%}
                  {%- assign platforms = platforms | push: p -%}
                {%- endunless -%}
              {%- endfor -%}
            {%- endfor -%}
          {%- endfor -%}
          {%- for platform in platforms -%}
            <label>
              <input type="checkbox" class="filter-checkbox" data-category="platform" value="{{ platform }}" onchange="filterProjects()">
              {{ platform }}
            </label>
          {%- endfor -%}
        </div>

        <!-- Subject -->
        <div class="filter">
          <strong>Subject:</strong>
          {%- assign subjects = "" | split: "" -%}
          {%- for grp in nav_group -%}
            {%- for item in grp.children -%}
              {%- for s in item.subjects -%}
                {%- unless subjects contains s -%}
                  {%- assign subjects = subjects | push: s -%}
                {%- endunless -%}
              {%- endfor -%}
            {%- endfor -%}
          {%- endfor -%}
          {%- for subject in subjects -%}
            <label>
              <input type="checkbox" class="filter-checkbox" data-category="subject" value="{{ subject }}" onchange="filterProjects()">
              {{ subject }}
            </label>
          {%- endfor -%}
        </div>

        <!-- SW/HW -->
        <div class="filter">
          <strong>SW/HW:</strong>
          {%- assign swhw_items = "" | split: "" -%}
          {%- for grp in nav_group -%}
            {%- for item in grp.children -%}
              {%- for tag in item["sw-hw"] -%}
                {%- unless swhw_items contains tag -%}
                  {%- assign swhw_items = swhw_items | push: tag -%}
                {%- endunless -%}
              {%- endfor -%}
            {%- endfor -%}
          {%- endfor -%}
          {%- for tag in swhw_items -%}
            <label>
              <input type="checkbox" class="filter-checkbox" data-category="sw-hw" value="{{ tag }}" onchange="filterProjects()">
              {{ tag }}
            </label>
          {%- endfor -%}
        </div>

        <!-- Support Level -->
        <div class="filter">
          <strong>Support Level:</strong>
          {%- assign levels = "" | split: "" -%}
          {%- for grp in nav_group -%}
            {%- for item in grp.children -%}
              {%- for lvl in item["support-level"] -%}
                {%- unless levels contains lvl -%}
                  {%- assign levels = levels | push: lvl -%}
                {%- endunless -%}
              {%- endfor -%}
            {%- endfor -%}
          {%- endfor -%}
          {%- for lvl in levels -%}
            <label>
              <input type="checkbox" class="filter-checkbox" data-category="support-level" value="{{ lvl }}" onchange="filterProjects()">
              {{ lvl }}
            </label>
          {%- endfor -%}
        </div>
      </div>

      <!-- 2) Two‐section project list -->
      <div class="project-results">
        {%- assign nav_root = site.data.navigation["projects"] -%}
        {%- for category in nav_root -%}
          <h2 class="project-group-title">{{ category.title }}</h2>
          <ul class="project-list">
            {%- for _child in category.children -%}
              {%- include snippets/get-nav-url.html path=_child.url -%}
              {%- assign _nav_url = __return -%}

              {%- comment -%}
              Normalize URL so it matches how site.posts/pages store .url
              (no site.url, no baseurl)
              {%- endcomment -%}
              {%- assign _nav_url_rel = _nav_url
                   | replace: site.url, ''
                   | replace: site.baseurl, '' -%}

              {%- comment -%}
              Resolve badges:
              1) Prefer badges from navigation data (_child.badges)
              2) If not present, look up the matching post/page by URL
                 and read its front-matter badges
              {%- endcomment -%}
              {%- assign _badges = _child.badges -%}
              {%- if _badges == nil or _badges == empty -%}
                {%- assign _doc = site.posts | where: "url", _nav_url_rel | first -%}
                {%- unless _doc -%}{%- assign _doc = site.pages | where: "url", _nav_url_rel | first -%}{%- endunless -%}
                {%- if _doc and _doc.badges -%}{%- assign _badges = _doc.badges -%}{%- endif -%}
              {%- endif -%}

              <li class="project-item"
                  data-platforms='{{ _child.platform | jsonify }}'
                  data-subjects='{{ _child.subjects | jsonify }}'
                  data-swhw='{{ _child["sw-hw"] | jsonify }}'
                  data-support-level='{{ _child["support-level"] | jsonify }}'
                  {%- if _badges -%} data-badges='{{ _badges | jsonify }}'{%- endif -%}
                  data-url-rel='{{ _nav_url_rel }}'>

               <header class="project-header">
  <a class="project-title" href="{{ _nav_url }}">{{ _child.title }}</a>

  {%- if _badges -%}
    <div class="project-badges">
      {% include badges.html items=_badges %}
    </div>
  {%- endif -%}
</header>


                <p class="project-desc">
                  {{ _child.description }}
                </p>
              </li>
            {%- endfor -%}
          </ul>
        {%- endfor -%}
      </div>

<script>
/* Robust project sort + filter (avoids leaving items behind) */
(function () {
  // --- Helpers -------------------------------------------------------------
  const isElement = n => n && n.nodeType === Node.ELEMENT_NODE;
  function safeParseJSON(raw) {
    if (!raw && raw !== '') return [];
    try {
      const p = JSON.parse(raw);
      return Array.isArray(p) ? p : [];
    } catch (e) {
      const cleaned = String(raw || '').replace(/^[\[\]'" ]+|[\[\]'" ]+$/g, '').trim();
      if (!cleaned) return [];
      return cleaned.split(',').map(s => String(s).trim()).filter(Boolean);
    }
  }
  function normalizeArray(arr) {
    return (arr || []).map(x => String(x).trim().toLowerCase()).filter(Boolean);
  }
  function badgesFromDOM(li) {
    const badgesEl = li.querySelector('.project-badges');
    if (!badgesEl) return [];
    return Array.from(badgesEl.querySelectorAll('*')).map(n => (n.textContent||'').trim()).filter(Boolean);
  }
  function getBadgesForItem(li) {
    const raw = li.getAttribute('data-badges') || li.dataset.badges || '';
    let parsed = safeParseJSON(raw);
    if (!parsed || parsed.length === 0) parsed = badgesFromDOM(li);
    return normalizeArray(parsed);
  }
  function badgeRank(normed) {
    const isTrending = normed.includes('trending');
    const isRecent =
      normed.includes('recently_added') ||
      normed.includes('recently-added') ||
      normed.includes('recentlyadded');
    if (isTrending && isRecent) return 0;
    if (isRecent) return 1;
    if (isTrending) return 2;
    return 3;
  }

  // --- Sorting state ------------------------------------------------------
  let observer = null;
  let debounceTimer = null;
  let isSorting = false;

  // Collects direct .project-item children of the provided UL (guarantees we get elements only)
  function collectListItems(ul) {
    return Array.from(ul.children).filter(ch => ch.classList && ch.classList.contains('project-item'));
  }

  // Build a stable, deterministic key for each item to detect duplicates / missing
  function itemKey(li) {
    // prefer data-url-rel (stable), fallback to text + index
    return li.getAttribute('data-url-rel') || (li.querySelector('.project-title') && li.querySelector('.project-title').textContent.trim()) || li.outerHTML.slice(0,100);
  }

  // Core: sort each .project-list atomically and robustly
  function sortProjectLists() {
    if (isSorting) return;
    isSorting = true;
    if (observer) observer.disconnect();

    // For safety: map of keys -> element across the whole document (helps if an li is temporarily detached)
    const allItemsMap = new Map();
    document.querySelectorAll('.project-item').forEach(li => {
      if (!isElement(li)) return;
      allItemsMap.set(itemKey(li), li);
    });

    document.querySelectorAll('.project-list').forEach(ul => {
      const originalItems = collectListItems(ul);
      if (originalItems.length === 0) return;

      // Build decorated array using items that belong to this ul *or* that have the same key and are elsewhere
      const decorated = originalItems.map((el, idx) => {
        const key = itemKey(el);
        // If the element was removed from DOM and exists in map, prefer that one (ensures we don't drop it)
        const canonical = allItemsMap.get(key) || el;
        const badges = getBadgesForItem(canonical);
        return { el: canonical, idx, rank: badgeRank(badges), key };
      });

      // Stable sort: by rank then original index
      decorated.sort((a, b) => (a.rank - b.rank) || (a.idx - b.idx));

      // Defensive check: ensure decorated covers all original keys — if not, try to recover missing items from global map
      const decoratedKeys = new Set(decorated.map(d => d.key));
      originalItems.forEach(el => {
        const k = itemKey(el);
        if (!decoratedKeys.has(k)) {
          const recovered = allItemsMap.get(k);
          if (recovered) {
            const badges = getBadgesForItem(recovered);
            decorated.push({ el: recovered, idx: originalItems.indexOf(el), rank: badgeRank(badges), key: k });
            decoratedKeys.add(k);
          }
        }
      });

      // Now create fragment and append in one shot
      const frag = document.createDocumentFragment();
      // Avoid duplicate appends: keep a set of appended elements
      const appended = new Set();
      decorated.forEach(d => {
        if (!isElement(d.el)) return;
        if (appended.has(d.el)) return;
        appended.add(d.el);
        frag.appendChild(d.el);
      });

      // If some items were in DOM but not in decorated (edge case), append them at the end to avoid losing them
      originalItems.forEach(el => {
        if (!appended.has(el)) {
          frag.appendChild(el);
          appended.add(el);
        }
      });

      // Temporarily lock pointer events on the UL during the move to avoid dropped clicks
      const prevPointer = ul.style.pointerEvents || '';
      ul.style.pointerEvents = 'none';

      requestAnimationFrame(() => {
        ul.appendChild(frag);
        // restore pointer-events after paint
        setTimeout(() => {
          ul.style.pointerEvents = prevPointer;
        }, 40);
      });
    });

    // reconnect observer
    startObserving();
    isSorting = false;
  }

  function scheduleSort() {
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(sortProjectLists, 100);
  }

  // --- Filtering (keeps behavior) -----------------------------------------
  function filterProjects() {
    const checks = Array.from(document.querySelectorAll('.filter-checkbox:checked'));
    if (checks.length === 0) {
      document.querySelectorAll('.project-item').forEach(el => el.style.display = '');
      return;
    }

    const activeFilters = checks.map(cb => ({ cat: cb.dataset.category, val: cb.value }));

    document.querySelectorAll('.project-item').forEach(li => {
      let plats = [], subs = [], swhws = [], levels = [];
      try { plats  = safeParseJSON(li.getAttribute('data-platforms') || li.dataset.platforms || '[]'); } catch(e){ plats=[]; }
      try { subs   = safeParseJSON(li.getAttribute('data-subjects')  || li.dataset.subjects  || '[]'); } catch(e){ subs=[]; }
      try { swhws  = safeParseJSON(li.getAttribute('data-swhw')      || li.dataset.swhw       || '[]'); } catch(e){ swhws=[]; }
      try { levels = safeParseJSON(li.getAttribute('data-support-level') || li.dataset.supportLevel || '[]'); } catch(e){ levels=[]; }

      const ok = activeFilters.every(f => {
        switch (f.cat) {
          case 'platform':      return plats.includes(f.val);
          case 'subject':       return subs.includes(f.val);
          case 'sw-hw':         return swhws.includes(f.val);
          case 'support-level': return levels.includes(f.val);
          default:              return true;
        }
      });
      li.style.display = ok ? '' : 'none';
    });
  }

  // Attach change handler for checkboxes
  document.addEventListener('change', function (ev) {
    const t = ev.target;
    if (t && t.classList && t.classList.contains('filter-checkbox')) {
      filterProjects();
      // after filter changes, re-sort to ensure "recent" items remain at top
      scheduleSort();
    }
  });

  // --- Mutation observer --------------------------------------------------
  function startObserving() {
    const container = document.querySelector('.project-results');
    if (!container) return;
    if (!observer) {
      observer = new MutationObserver(mutations => {
        // If children changed, reschedule. We specifically avoid reacting to attribute-only noise.
        let sawChildChange = false;
        for (const m of mutations) {
          if (m.type === 'childList' && (m.addedNodes.length || m.removedNodes.length)) { sawChildChange = true; break; }
        }
        if (sawChildChange) scheduleSort();
      });
    }
    observer.observe(container, { childList: true, subtree: true });
  }

  // --- Boot ---------------------------------------------------------------
  document.addEventListener('DOMContentLoaded', () => {
    // initial sort
    sortProjectLists();
    // secondary pass for late badges
    setTimeout(sortProjectLists, 300);
    startObserving();
  });

  // Expose for debugging
  window.__arm_sortProjectLists = sortProjectLists;
  window.__arm_filterProjects = filterProjects;
})();
</script>


    {%- endif -%}
  </div>

  {%- if _sharing -%}
    <section class="article__sharing d-print-none">{%- include sharing.html -%}</section>
  {%- endif -%}

  <div class="d-print-none">
    {%- include article-footer.html -%}
  </div>
</div>




